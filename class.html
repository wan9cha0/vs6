<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>es6-class</title>
</head>
<style>
  div {
    font-size: 2rem;
  }
</style>

<body>
  <div class="one"></div>
  <div class="two"></div>
  <script>
    function Point(x, y) {
      this.x = x
      this.y = y
    }

    Point.prototype.toString = function () {
      return `(${this.x},${this.y})`
    }

    let x = new Point(1, 2)
    document.querySelector('.one').innerHTML = x.toString()

    class Points {
      constructor(x, y) {
        this.x = x
        this.y = y
      }

      toString() {
        return `(${this.x},${this.y})`
      }
    }

    let y = new Points(2, 3)

    document.querySelector('.two').innerHTML = y.toString()
    /*      __proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，
         虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。
         生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。 */

    class MyClass {
      constructor() {
        // ...
      }
      get prop() {
        return 'getter';
      }
      set prop(value) {
        console.log('setter: ' + value);
      }
    }

    let inst = new MyClass();

    inst.prop = 123;
    // setter: 123

    console.log(inst.prop);
    // 'getter'
  </script>
</body>

</html>